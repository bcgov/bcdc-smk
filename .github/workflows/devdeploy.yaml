
name: "DEV Deploy"

#TODO: once working change the event the action is associated to the one below
# on:
#   workflow_run:
#     workflows: ["BUILDPackage", "build"]
#     types: 
#       - completed

on: 
  push:
    branches: ['dev']

jobs:
  deploydev:
    defaults:
      run:
        shell: bash
    # RETRIEVE IMAGE TAGS
    runs-on: ubuntu-18.04
    outputs:
      dockerversiontag: ${{ steps.retrieveimagetag.outputs.DOCKER_VERSION_TAG }}
      routepath: ${{ steps.deploydev.outputs.ROUTEPATH }}
    steps:
    # Checking out code to get access to the openshift deploy template later on
    # could also reference the github url?
    - uses: actions/checkout@v2
      id: checkout
      with:
        fetch-depth: 0

      # RETRIEVE THE IMAGE TAG
    - name: Retrieve image tag
      id: retrieveimagetag
      run: |
        #--------------------------------------------------------
        #
        #--- set the artifacts url
        artifactsUrl="${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/actions/artifacts"
        echo artifacts url is $artifactsUrl

        # --- get the last artifacts download url
        artifactDlUrl=$(curl --location --header "authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" --request GET $artifactsUrl | jq '.artifacts[0].archive_download_url' | tr -d '"')
        echo  artifact download link is $artifactDlUrl
        
        # --- download the last artifact and unzip it
        curl --location --request GET $artifactDlUrl --header 'Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' --data-raw '' --output arty.zip
        echo downloaded artifact arty.zip
        unzip arty.zip

        # -- populate the env var IMAGE_TAG
        IMAGE_TAG=$(cat docker_image_tag.txt)
        echo image tag is $IMAGE_TAG
        echo ::set-output name=DOCKER_VERSION_TAG::$IMAGE_TAG

        #echo "::set-env name=DOCKER_VERSION_TAG::$IMAGE_TAG"
        echo testing set of env var: ${{ env.DOCKER_VERSION_TAG }}

        # Clean up the downloaded artifact
        rm docker_image_tag.txt
        rm arty.zip
        
    # LOGGING INTO OC
    - name: OpenShift Action
      id: GHAOpenshiftTest
      uses: redhat-developer/openshift-actions@v1.1
      with:
        version: '3.11.232'
        openshift_server_url: ${{ secrets.OPENSHIFT_SERVER_URL }}
        parameters: '{"apitoken": "${{ secrets.OPENSHIFT_TOKEN_DEV }}", "acceptUntrustedCerts": "true"}'
        cmd: 'version'
     
    # PERFORM THE DEPLOY
    - name: deploy dev
      id: deploydev
      run: |
        oc version
        oc whoami
        oc status
        whereis oc

        #TODO:
        # need to create a service account in the namespace defined for this 
        # deploy, also want to define the role for that service account, and
        # put it all in a TEMPLATE

        #TODO: parameterize this in an env var
        DEPLOY_NAMESPACE=${{ secrets.OPENSHIFT_DEV_NAMESPACE }}
        echo deploy namespace is $DEPLOY_NAMESPACE
        echo docker tag $DOCKER_VERSION_TAG

        echo tag version is ${{ steps.retrieveimagetag.outputs.DOCKER_VERSION_TAG }}


        # ------------------- extract the object names from the template -------------------
        ROUTENAME=$(oc process -f ./openshift/deployTemplate.yaml -p ENV=dev -p IMAGE_LABEL=$DOCKER_VERSION_TAG | jq '.items[] | select(.kind=="Route") | .metadata.name' | tr -d '"')
        DEPLOYNAME=$(oc process -f ./openshift/deployTemplate.yaml -p ENV=dev -p IMAGE_LABEL=$DOCKER_VERSION_TAG  | jq '.items[] | select(.kind=="DeploymentConfig") | .metadata.name'| tr -d '"')
        SERVICENAME=$(oc process -f ./openshift/deployTemplate.yaml -p ENV=dev -p IMAGE_LABEL=$DOCKER_VERSION_TAG  | jq '.items[] | select(.kind=="Service") | .metadata.name' | tr -d '"')
        echo routename $ROUTENAME
        echo depoloyname $DEPLOYNAME
        echo servicename $SERVICENAME

        # ------------------- delete objects if they exist -------------------
        EXISTINGDEPLOYNAME=$(oc get deploymentconfigs -n $DEPLOY_NAMESPACE -o json | jq  '.items[] | select(.metadata.name=="'$DEPLOYNAME'") | .metadata.name' | tr -d '"')
        echo existing deploy name $EXISTINGDEPLOYNAME
        if [ ! -z "$EXISTINGDEPLOYNAME" ]
        then
          echo deleting $EXISTINGDEPLOYNAME
          oc delete deploymentconfig $EXISTINGDEPLOYNAME
        fi
        echo route name is $ROUTENAME
        EXISTINGROUTENAME=$(oc get routes -n $DEPLOY_NAMESPACE -o json | jq  '.items[] | select(.metadata.name=="'$ROUTENAME'") | .metadata.name' | tr -d '"')
        if [ ! -z "$EXISTINGROUTENAME" ]
        then
          oc delete route $EXISTINGROUTENAME
        fi
        EXISTINGSERVICENAME=$(oc get services -n $DEPLOY_NAMESPACE -o json | jq  '.items[] | select(.metadata.name=="'$SERVICENAME'") | .metadata.name' | tr -d '"')
        echo service name is $EXISTINGSERVICENAME
        if [ ! -z "$EXISTINGSERVICENAME" ]
        then
          oc delete service $EXISTINGSERVICENAME
        fi

        # ------------------- NOW CREATE THE OBJECTS -------------------
        oc process -f ./openshift/deployTemplate.yaml -p ENV=dev -p IMAGE_LABEL=${{ steps.retrieveimagetag.outputs.DOCKER_VERSION_TAG }} -p DEPLOY_NAMESPACE=$DEPLOY_NAMESPACE | oc create -n $DEPLOY_NAMESPACE -f - 

        echo route name is $ROUTENAME
        # ---- get the path associated with the route
        ROUTEPATH=$(oc get routes -n ${{ secrets.OPENSHIFT_DEV_NAMESPACE }} -o json | jq  '.items[] | select(.metadata.name=="'$ROUTENAME'") | .spec.host' | tr -d '"')
        echo route is 'https://'$ROUTEPATH

        # ------------------- SET THE ROUTEPATH ouptut
        echo ::set-output name=ROUTEPATH::$ROUTEPATH

    # ADD A DEPLOY MONITOR STEP TO MAKE SURE IT WAS SUCCESSFUL

    # ADD THE ROUTE TO THE ISSUE
    - name: Update issue
      id: updateissue
      run: |
        # add a comment for the issue associated with the pr that includes the 
        # path to the dev deploy of the app
        #
        # possibly also do a 'request' for reviews to someone defined in an env 
        # var somewhere
        # change the status of the pull request to "review required"
        echo "not implemented yet"
        echo route path is ${{ steps.deploydev.outputs.ROUTEPATH }}
        cat $GITHUB_EVENT_PATH

        issue_url=$(jq --raw-output .pull_request.issue_url "$GITHUB_EVENT_PATH")
        # for debugging using existing pull_request
        if [ -z "$issue_url" ] || [ "$issue_url" = "null" ]
          then
            issue_url="https://api.github.com/repos/bcgov/bcdc-smk/issues/19"
        fi

        # add the route to the issue url
        curl -X POST -H "Accept: application/vnd.github.v3+json" \
          --header "authorization: Bearer $GITHUB_TOKEN" \
        https://api.github.com/repos/bcgov/bcdc-smk/issues/19/comments \
        -d '{"body":"testing add comment"}'

        ISSUE_COMMENT="link to demo deployment of app\n ${{ steps.deploydev.outputs.ROUTEPATH }}"
        curl -X POST --location --header "authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
          --header "Accept: application/vnd.github.v3+json" \
          $issue_url -d '{"body":"'$ISSUE_COMMENT'"}'


    # REQUEST A REVIEW





