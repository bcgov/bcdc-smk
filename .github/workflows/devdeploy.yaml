
name: "DEV Deploy"

#TODO: once working change the event the action is associated to the one below
# on:
#   workflow_run:
#     workflows: ["BUILDPackage", "build"]
#     types: 
#       - completed

on: 
  push:
    branches: ['dev']

jobs:
  deploydev:
    defaults:
      run:
        shell: bash
    # RETRIEVE IMAGE TAGS
    runs-on: ubuntu-18.04
    outputs:
      dockerversiontag: ${{ steps.retrieveimagetag.outputs.DOCKER_VERSION_TAG }}
    steps:
    # Checking out code to get access to the openshift deploy template later on
    # could also reference the github url?
    - uses: actions/checkout@v2
      id: checkout
      with:
        fetch-depth: 0


    - name: Retrieve image tag
      id: retrieveimagetag
      run: |
        #--- set the artifacts url
        artifactsUrl="${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/actions/artifacts"
        echo artifacts url is $artifactsUrl

        # --- get the last artifacts download url
        artifactDlUrl=$(curl --location --header "authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" --request GET $artifactsUrl | jq '.artifacts[0].archive_download_url' | tr -d '"')
        echo  artifact download link is $artifactDlUrl
        
        # --- download the last artifact and unzip it
        curl --location --request GET $artifactDlUrl --header 'Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' --data-raw '' --output arty.zip
        echo downloaded artifact arty.zip
        unzip arty.zip

        # -- populate the env var IMAGE_TAG
        IMAGE_TAG=$(cat docker_image_tag.txt)
        echo image tag is $IMAGE_TAG
        echo ::set-output name=DOCKER_VERSION_TAG::$IMAGE_TAG

        #echo "::set-env name=DOCKER_VERSION_TAG::$IMAGE_TAG"
        echo testing set of env var: ${{ env.DOCKER_VERSION_TAG }}

        # Clean up the downloaded artifact
        rm docker_image_tag.txt
        rm arty.zip
        
    # LOGGING INTO OC
    - name: OpenShift Action
      id: GHAOpenshiftTest
      uses: redhat-developer/openshift-actions@v1.1
      with:
        version: '3.11.232'
        openshift_server_url: ${{ secrets.OPENSHIFT_SERVER_URL }}
        parameters: '{"apitoken": "${{ secrets.OPENSHIFT_TOKEN_DEV }}", "acceptUntrustedCerts": "true"}'
        cmd: 'version'
     
    # PERFORM THE DEPLOY
    - name: deploy dev
      id: deploydev
      run: |
        oc version
        oc whoami
        oc status
        whereis oc

        #TODO:
        # need to create a service account in the namespace defined for this 
        # deploy, also want to define the role for that service account, and
        # put it all in a TEMPLATE

        #TODO: parameterize this in an env var
        DEPLOY_NAMESPACE=${{ secrets.OPENSHIFT_DEV_NAMESPACE }}
        echo deploy namespace is $DEPLOY_NAMESPACE

        # ------------------- extract the object names from the template -------------------
        ROUTENAME=$(oc process -f ./openshift/deployTemplate.yaml -p ENV=dev -p IMAGE_LABEL=$DOCKER_VERSION_TAG | jq '.items[] | select(.kind=="Route") | .metadata.name')
        DEPLOYNAME=$(oc process -f ./openshift/deployTemplate.yaml -p ENV=dev -p IMAGE_LABEL=$DOCKER_VERSION_TAG  | jq '.items[] | select(.kind=="DeploymentConfig") | .metadata.name')
        SERVICENAME=$(oc process -f ./openshift/deployTemplate.yaml -p ENV=dev -p IMAGE_LABEL=$DOCKER_VERSION_TAG  | jq '.items[] | select(.kind=="Service") | .metadata.name')
        
        # ------------------- delete objects if they exist -------------------
        EXISTINGDEPLOYNAME=$(oc get deploymentconfigs -n $DEPLOY_NAMESPACE -o json | jq  '.items[] | select(.metadata.name=='$DEPLOYNAME') | .metadata.name')
        if [ ! -z "$EXISTINGDEPLOYNAME" ]
        then
          oc delete deploymentconfig $EXISTINGDEPLOYNAME
        fi
        EXISTINGROUTENAME=$(oc get routes -n $DEPLOY_NAMESPACE -o json | jq  '.items[] | select(.metadata.name=='$ROUTENAME') | .metadata.name')
        if [ ! -z "$EXISTINGROUTENAME" ]
        then
          oc delete route $EXISTINGROUTENAME
        fi
        EXISTINGSERVICENAME=$(oc get deploymentconfigs -n $DEPLOY_NAMESPACE -o json | jq  '.items[] | select(.metadata.name=='$SERVICENAME') | .metadata.name')
        if [ ! -z "$EXISTINGSERVICENAME" ]
        then
          oc delete route $EXISTINGSERVICENAME
        fi

        # ------------------- NOW CREATE THE OBJECTS -------------------
        oc process -f ./openshift/deployTemplate.yaml -p ENV=dev -p IMAGE_LABEL=$DOCKER_VERSION_TAG -p DEPLOY_NAMESPACE=$DEPLOY_NAMESPACE | oc create -n $DEPLOY_NAMESPACE -f - 

        echo route name is $ROUTENAME
        ROUTEPATH=$(oc get routes -n $OPENSHIFT_DEV_NAMESPACE -o json | jq  '.items[] | select(.metadata.name=='$ROUTENAME') | .spec.host' | tr -d '"')
        echo route is 'https://'$ROUTEPATH

        # ------------------- SET THE ROUTEPATH ouptut
        run: echo ::set-output name=ROUTEPATH::$(ROUTEPATH)

    - name: Update issue
      id: updateissue
      run: |
        # add a comment for the issue associated with the pr that includes the 
        # path to the dev deploy of the app
        #
        # possibly also do a 'request' for reviews to someone defined in an env 
        # var somewhere
        # change the status of the pull request to "review required"
        echo "not implemented yet"
  